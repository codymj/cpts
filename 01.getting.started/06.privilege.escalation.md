# Privilege Escalation

## PrivEsc Checklists

Once we gain initial access to a box, we want to thoroughly enumerate the box to find any potential vulnerabilities we can exploit to achieve a higher privilege level.

* [HackTricks](https://book.hacktricks.xyz)
* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)

## Enumeration Scripts

* [LinEnum](https://github.com/rebootuser/LinEnum.git)
* [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker)
* [Privilege Escalation Awesome Scripts SUITE (PEASS)](https://github.com/peass-ng/PEASS-ng)

## Kernel Exploits

Whenever we encounter a server running an old operating system, we should start by looking for potential kernel vulnerabilities that may exist.

Googling for exploits pertaining to the kernel version, such as `3.9.0-73-generic` could lead to some CVEs. Same for Windows versions.

We should keep in mind that kernel exploits can cause system instability, and we should take great care before running them on production systems.

## Vulnerable Software

Another thing we should look for is installed software. For example, we can use the `dpkg -l` command on Linux or look at `C:\Program Files` in Windows to see what software is installed on the system. We should look for public exploits for any installed software, especially if any older versions are in use, containing unpatched vulnerabilities.

## User Privileges

Another critical aspect to look for after gaining access to a server is the privileges available to the user we have access to.

We can check what sudo privileges we have with the `sudo -l` command:

```bash
$ sudo -l

[sudo] password for user1:

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```

The above output says that we can run all commands with sudo, which gives us complete access, and we can use the su command with sudo to switch to the root user:

```bash
$ sudo su -

[sudo] password for user1:
whoami
root
```

Or, if we only have `sudo` privileges for a specific binary:

```bash
$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```

As it says user, we can run `sudo` as that user and not as root. To do so, we can specify the user with -u user:

```bash
$ sudo -u user /bin/echo Hello World!

Hello World!
```

Once we find a particular application we can run with `sudo`, we can look for ways to exploit it to get a shell as the root user. Some resources:

* [GTFOBins](https://gtfobins.github.io)
* [LOLBAS](https://lolbas-project.github.io)

## Scheduled Tasks

In both Linux and Windows, there are methods to have scripts run at specific intervals to carry out a task. There are usually two ways to take advantage of scheduled tasks (Windows) or cron jobs (Linux) to escalate our privileges:

1. Add new scheduled tasks/cron jobs
2. Trick them to execute a malicious software

There are specific directories that we may be able to utilize to add new cron jobs if we have the write permissions over them. These include:

1. `/etc/crontab`
2. `/etc/cron.d`
3. `/var/spool/cron/crontabs/root`

If we can write to a directory called by a cron job, we can write a bash script with a reverse shell command, which should send us a reverse shell when executed.

## Exposed Credentials

Next, we can look for files we can read and see if they contain any exposed credentials. This is very common with configuration files, log files, and user history files (`bash_history` in Linux and `PSReadLine` in Windows).

## SSH Keys

If we have read access over the `.ssh` directory for a specific user, we may read their private SSH keys found in `/home/user/.ssh/id_rsa` or `/root/.ssh/id_rsa`, and use it to log in to the server. If we can read the `/root/.ssh/` directory and can read the `id_rsa` file, we can copy it to our machine and use the `-i` flag to log in with it:

```bash
$ vim id_rsa
$ chmod 600 id_rsa
$ ssh root@10.10.10.10 -i id_rsa

root@10.10.10.10#
```

If we find ourselves with write access to a users `.ssh/` directory, we can place our public key in the user's SSH directory at `/home/user/.ssh/authorized_keys`:

```bash
$ ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:... user@parrot...

$ echo "ssh-rsa AAAAB...M= user@parrot" >> /root/.ssh/authorized_keys
$ ssh root@10.10.10.10 -i key

root@remotehost# 
```
